==문제==========================
문제 타이틀 : 이친수
이친수의 정의
1. 1과 0으로만 이루어진 수
2. 1로 시작하는 수
3. 1이 연속으로 등장하지 않는 수

010001 : 2에 위배
101100 : 3에 위배

입력 : 90이하의 자연수 N
출력 : N자리수의 이친수의 개수

==접근==========================
가장 먼저 떠오른 생각은 1로 시작하니까 경우의 수를 추리기가 쉽다는 것이다.
1로 시작하면 다음수는 0일 수 밖에 없다.
N이 10이면 10XXXXXXXX의 패턴으로 나올 수 밖에 없다.
0 다음에 오는 수는 0일 수도 있고, 1일 수도 있다.

재귀로 접근한다면 자리수를 줄여가면서 이전 수가 1이었는지 0이었는지에 따라 그 다음 자리수를 결정 짓고,
이전 자리수가 0이었으면 0과 1로 재귀, 이전 자리수가 1이었으면 0으로만 재귀이며, 결국 이전 자리수가 1일때 다음 자리수에 영향을 주기 때문에 아래와 같은 재귀 구조가 된다. 그리고 n이 0이하 때, 함수를 빠져나가준다.

f(prev, n)
    if(n<=0)
        result += 1
        return;
    if(prev != 1)
        f(1, n-1)
    f(0, n-1)

하지만 재귀로 했을 때, 숫자가 커지면 비용도 커진다. 숫자가 1 커지면 최대 2배까지 비용이 커진다. 사실 2배까지는 아니고 이것도 계산가능할 것 같지만 연구할 필요는 없다.

n자리수일 때, 첫번째 수가 0과 1로 정의된다고 하고, n-1자리수가 계산되어 있으면, 두 경우의 결과값을 바로 얻을 수 있다. 결과값은 (n-1)의 0의 경우와 동일하다. 왜냐하면 앞에서 얘기했듯이 이친수의 정의에 들어맞으려면 10XX.. 으로 시작할 수 밖에 없기 때문이다.
f(0, 1) = 1, f(1, 1)을 1로 해두고 f(0, 2), f(1, 2), f(0, 3), f(1, 3), ...을 계속 계산해나가면 O(n)으로 계산할 수 있다.
f(p, n)이라고 할 때(p는 이전 자리가 0인지 1인지, n은 자리수), p가 0이면 그 값은, f(0, n-1) + f(1, n-1)과 같다. p가 1이면 f(0, n-1)과 같다.

정리하면 아래와 같다. 인자의 순서를 바꿨으면 더 읽기 편했을 것 같다.
f(0, n) = f(0, n-1) + f(1, n-1)
f(1, n) = f(0, n-1)


==결론==========================
f(1) = 1, f(2) = 1 이고 f(n) = f(n-2) + f(n-1)과 결과가 같고 피보나치의 수와 동치이다.
